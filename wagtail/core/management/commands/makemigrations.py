import difflib
import hashlib
import os
import re
from pprint import pformat

from django import get_version
from django.core.management.commands.makemigrations import Command as DjangoCommand
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.writer import MigrationWriter, OperationWriter
from django.utils.timezone import now

from wagtail.core.blocks.utils import recursive_deconstruct
from wagtail.migrations import AlterStreamField


def indent(text, amount):
    padding = amount * " "
    return "".join(
        padding + line.rstrip() + "\n" if line.strip() else "\n"
        for line in text.splitlines(True)
    )


MIGRATION_TEMPLATE = """\
# Generated by Django %(version)s on %(timestamp)s

%(imports)s%(alterstreamfields)s

class Migration(migrations.Migration):
%(replaces_str)s%(initial_str)s
    dependencies = [
%(dependencies)s\
    ]

    operations = [
%(operations)s\
    ]
"""


ALTERSTREAMFIELD_TEMPLATE = """\
class AlterStreamField%(docstring_hash)s(AlterStreamField):
    \"\"\"
    This migration applies to these fields:
%(fields)s

%(states)s
    \"\"\"

    def transform_values(self, values):
        \"\"\"
        This method receives the list of values of the field in the old format
        and should return the list of values of the field in the new format

        [
            {
                'type': ...,
                'value': ...,
                'id': ...,
            },
            ...,
        ]
        \"\"\"
        return [self.transform_value(value) for value in values]

    def transform_value(self, value):
        \"\"\"
        This method receives each individual value of the field in the old
        format and should return a value in the new format

        {
            'type': ...,
            'value': ...,
            'id': ...,
        }
        \"\"\"
        raise NotImplementedError('Please define the transform_value method of AlterStreamField%(docstring_hash)s')
"""


class WagtailMigrationWriter(MigrationWriter):
    def as_string(self, alterstreamfields):
        """Return a string of the file contents."""
        items = {
            "replaces_str": "",
            "initial_str": "",
            "alterstreamfields": alterstreamfields,
        }

        imports = set()

        # Deconstruct operations
        operations = []
        for operation in self.migration.operations:
            operation_string, operation_imports = OperationWriter(operation).serialize()
            if isinstance(operation, AlterStreamField):
                operation_string = operation_string.replace(
                    "wagtail.core.management.commands.makemigrations.AlterStreamField",
                    "AlterStreamField",
                )
                operation_imports.discard(
                    "import wagtail.core.management.commands.makemigrations"
                )
                operation_imports.add("from wagtail.migrations import AlterStreamField")
            imports.update(operation_imports)
            operations.append(operation_string)
        items["operations"] = "\n".join(operations) + "\n" if operations else ""

        # Format dependencies and write out swappable dependencies right
        dependencies = []
        for dependency in self.migration.dependencies:
            if dependency[0] == "__setting__":
                dependencies.append(
                    "        migrations.swappable_dependency(settings.%s),"
                    % dependency[1]
                )
                imports.add("from django.conf import settings")
            else:
                dependencies.append("        %s," % self.serialize(dependency)[0])
        items["dependencies"] = "\n".join(dependencies) + "\n" if dependencies else ""

        # Format imports nicely, swapping imports of functions from migration files
        # for comments
        migration_imports = set()
        for line in list(imports):
            if re.match(r"^import (.*)\.\d+[^\s]*$", line):
                migration_imports.add(line.split("import")[1].strip())
                imports.remove(line)
                self.needs_manual_porting = True

        # django.db.migrations is always used, but models import may not be.
        # If models import exists, merge it with migrations import.
        if "from django.db import models" in imports:
            imports.discard("from django.db import models")
            imports.add("from django.db import migrations, models")
        else:
            imports.add("from django.db import migrations")

        # Sort imports by the package / module to be imported (the part after
        # "from" in "from ... import ..." or after "import" in "import ...").
        sorted_imports = sorted(imports, key=lambda i: i.split()[1])
        items["imports"] = "\n".join(sorted_imports) + "\n" if imports else ""
        if migration_imports:
            items["imports"] += (
                "\n\n# Functions from the following migrations need manual "
                "copying.\n# Move them and any dependencies into this file, "
                "then update the\n# RunPython operations to refer to the local "
                "versions:\n# %s"
            ) % "\n# ".join(sorted(migration_imports))
        # If there's a replaces, make a string for it
        if self.migration.replaces:
            items["replaces_str"] = (
                "\n    replaces = %s\n" % self.serialize(self.migration.replaces)[0]
            )
        # Hinting that goes into comment
        items.update(version=get_version(), timestamp=now().strftime("%Y-%m-%d %H:%M"))

        if self.migration.initial:
            items["initial_str"] = "\n    initial = True\n"

        return MIGRATION_TEMPLATE % items


class Command(DjangoCommand):
    def handle(self, *app_labels, **options):
        super().handle(*app_labels, **options)

    def write_migration_files(self, changes):
        alterstreamfields, changes = self.create_alterstreamfields(changes)
        directory_created = {}
        for app_label, app_migrations in changes.items():
            if self.verbosity >= 1:
                self.stdout.write(
                    self.style.MIGRATE_HEADING("Migrations for '%s':" % app_label) + "\n"
                )
            for migration in app_migrations:
                # Describe the migration
                writer = WagtailMigrationWriter(migration)
                if self.verbosity >= 1:
                    # Display a relative path if it's below the current working
                    # directory, or an absolute path otherwise.
                    try:
                        migration_string = os.path.relpath(writer.path)
                    except ValueError:
                        migration_string = writer.path
                    if migration_string.startswith(".."):
                        migration_string = writer.path
                    self.stdout.write(
                        "  %s\n" % (self.style.MIGRATE_LABEL(migration_string),)
                    )
                    for operation in migration.operations:
                        self.stdout.write("    - %s\n" % operation.describe())
                if not self.dry_run:
                    # Write the migrations file to the disk.
                    migrations_directory = os.path.dirname(writer.path)
                    if not directory_created.get(app_label):
                        if not os.path.isdir(migrations_directory):
                            os.mkdir(migrations_directory)
                        init_path = os.path.join(migrations_directory, "__init__.py")
                        if not os.path.isfile(init_path):
                            open(init_path, "w").close()
                        # We just do this once per app
                        directory_created[app_label] = True
                    migration_string = writer.as_string(alterstreamfields)
                    with open(writer.path, "w", encoding="utf-8") as fh:
                        fh.write(migration_string)
                elif self.verbosity == 3:
                    # Alternatively, makemigrations --dry-run --verbosity 3
                    # will output the migrations to stdout rather than saving
                    # the file to the disk.
                    self.stdout.write(
                        self.style.MIGRATE_HEADING(
                            "Full migrations file '%s':" % writer.filename
                        ) + "\n"
                    )
                    self.stdout.write("%s\n" % writer.as_string(alterstreamfields))

    def create_alterstreamfields(self, changes):
        alterstreamfields = {}
        loader = MigrationLoader(None, ignore_no_migrations=True)
        project_state = loader.project_state()
        for app_label, app_migrations in list(changes.items()):
            new_migrations = []
            for migration in app_migrations:
                new_operations = []
                for operation in migration.operations:
                    name, args, kwargs = operation.deconstruct()
                    field = kwargs.get("field", None)
                    if (
                        name == "AlterField" and field.__class__.__name__ == "StreamField"
                    ):
                        pre_state = project_state.models[
                            (app_label, operation.model_name_lower)
                        ]
                        pre_stream_block = pformat(
                            recursive_deconstruct(
                                pre_state.get_field_by_name(
                                    operation.name
                                ).stream_block,
                                with_kwargs=False,
                            )
                        )
                        post_stream_block = pformat(
                            recursive_deconstruct(
                                operation.field.stream_block, with_kwargs=False
                            )
                        )
                        docstring = "Before state:\n{}\n\nAfter state:\n{}\n\nDiff:\n{}".format(
                            pre_stream_block,
                            post_stream_block,
                            "".join(
                                difflib.unified_diff(
                                    pre_stream_block.splitlines(True),
                                    post_stream_block.splitlines(True),
                                )
                            ),
                        )
                        docstring_hash = (
                            hashlib.sha1(docstring.encode()).hexdigest()[:8].upper()
                        )
                        specific_class = type(
                            "AlterStreamField{}".format(docstring_hash),
                            (AlterStreamField,),
                            {},
                        )
                        if docstring_hash not in alterstreamfields:
                            alterstreamfields[docstring_hash] = {
                                "docstring_hash": docstring_hash,
                                "states": indent(docstring, 4),
                                "fields": set(),
                            }
                        alterstreamfields[docstring_hash]["fields"].add(
                            "{model}.{field}".format(
                                model=operation.field.model.__name__,
                                field=operation.name,
                            )
                        )
                        operation = specific_class(*args, **kwargs)
                    new_operations.append(operation)
                migration.operations = new_operations
                new_migrations.append(migration)
            changes[app_label] = new_migrations
        if alterstreamfields:
            for key in alterstreamfields:
                alterstreamfields[key]["fields"] = "\n".join(
                    [
                        "    - {}".format(field)
                        for field in sorted(alterstreamfields[key]["fields"])
                    ]
                )
            alterstreamfields = "\n\n" + "\n\n".join(
                [
                    ALTERSTREAMFIELD_TEMPLATE % alterstreamfields[key]
                    for key in sorted(alterstreamfields.keys())
                ]
            )
        else:
            alterstreamfields = ""
        return alterstreamfields, changes
